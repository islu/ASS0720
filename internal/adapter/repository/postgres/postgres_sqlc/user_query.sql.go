// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: user_query.sql

package postgres_sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTask = `-- name: CreateTask :one
/*
    task
*/

INSERT INTO task (
    task_group_no, task_name, task_desc, start_time, end_time
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING seqno, task_group_no, task_name, task_desc, start_time, end_time
`

type CreateTaskParams struct {
	TaskGroupNo int32
	TaskName    string
	TaskDesc    string
	StartTime   time.Time
	EndTime     time.Time
}

// Create task
//
//	/*
//	    task
//	*/
//
//	INSERT INTO task (
//	    task_group_no, task_name, task_desc, start_time, end_time
//	) VALUES (
//	    $1, $2, $3, $4, $5
//	)
//	RETURNING seqno, task_group_no, task_name, task_desc, start_time, end_time
func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.TaskGroupNo,
		arg.TaskName,
		arg.TaskDesc,
		arg.StartTime,
		arg.EndTime,
	)
	var i Task
	err := row.Scan(
		&i.Seqno,
		&i.TaskGroupNo,
		&i.TaskName,
		&i.TaskDesc,
		&i.StartTime,
		&i.EndTime,
	)
	return i, err
}

const createUserTask = `-- name: CreateUserTask :one
/*
    user_task
*/

INSERT INTO user_task (
    task_seqno, wallet_address, total_amount, point, status, create_time, update_time
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING task_seqno, wallet_address, total_amount, point, status, create_time, update_time
`

type CreateUserTaskParams struct {
	TaskSeqno     int32
	WalletAddress string
	TotalAmount   int64
	Point         int32
	Status        string
	CreateTime    time.Time
	UpdateTime    time.Time
}

// Create user task
//
//	/*
//	    user_task
//	*/
//
//	INSERT INTO user_task (
//	    task_seqno, wallet_address, total_amount, point, status, create_time, update_time
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6, $7
//	)
//	RETURNING task_seqno, wallet_address, total_amount, point, status, create_time, update_time
func (q *Queries) CreateUserTask(ctx context.Context, arg CreateUserTaskParams) (UserTask, error) {
	row := q.db.QueryRow(ctx, createUserTask,
		arg.TaskSeqno,
		arg.WalletAddress,
		arg.TotalAmount,
		arg.Point,
		arg.Status,
		arg.CreateTime,
		arg.UpdateTime,
	)
	var i UserTask
	err := row.Scan(
		&i.TaskSeqno,
		&i.WalletAddress,
		&i.TotalAmount,
		&i.Point,
		&i.Status,
		&i.CreateTime,
		&i.UpdateTime,
	)
	return i, err
}

const getTask = `-- name: GetTask :one
SELECT seqno, task_group_no, task_name, task_desc, start_time, end_time FROM task
WHERE seqno = $1
`

// Get task
//
//	SELECT seqno, task_group_no, task_name, task_desc, start_time, end_time FROM task
//	WHERE seqno = $1
func (q *Queries) GetTask(ctx context.Context, seqno int32) (Task, error) {
	row := q.db.QueryRow(ctx, getTask, seqno)
	var i Task
	err := row.Scan(
		&i.Seqno,
		&i.TaskGroupNo,
		&i.TaskName,
		&i.TaskDesc,
		&i.StartTime,
		&i.EndTime,
	)
	return i, err
}

const listTask = `-- name: ListTask :many
SELECT seqno, task_group_no, task_name, task_desc, start_time, end_time FROM task
ORDER BY start_time
`

// List task
//
//	SELECT seqno, task_group_no, task_name, task_desc, start_time, end_time FROM task
//	ORDER BY start_time
func (q *Queries) ListTask(ctx context.Context) ([]Task, error) {
	rows, err := q.db.Query(ctx, listTask)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.Seqno,
			&i.TaskGroupNo,
			&i.TaskName,
			&i.TaskDesc,
			&i.StartTime,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTaskByGroupNo = `-- name: ListTaskByGroupNo :many
SELECT seqno, task_group_no, task_name, task_desc, start_time, end_time FROM task
WHERE task_group_no = $1
ORDER BY start_time
`

// List task by task_group_no
//
//	SELECT seqno, task_group_no, task_name, task_desc, start_time, end_time FROM task
//	WHERE task_group_no = $1
//	ORDER BY start_time
func (q *Queries) ListTaskByGroupNo(ctx context.Context, taskGroupNo int32) ([]Task, error) {
	rows, err := q.db.Query(ctx, listTaskByGroupNo, taskGroupNo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.Seqno,
			&i.TaskGroupNo,
			&i.TaskName,
			&i.TaskDesc,
			&i.StartTime,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserTask_Join = `-- name: ListUserTask_Join :many
SELECT
    ut.task_seqno,
    t.task_name,
    t.task_desc,
    t.start_time,
    t.end_time,
    ut.wallet_address,
    ut.total_amount,
    ut.point,
    ut.status,
    ut.create_time,
    ut.update_time
FROM user_task ut
LEFT JOIN task t ON ut.task_seqno = t.seqno
WHERE ut.wallet_address = $1
ORDER BY t.start_time desc
`

type ListUserTask_JoinRow struct {
	TaskSeqno     int32
	TaskName      pgtype.Text
	TaskDesc      pgtype.Text
	StartTime     pgtype.Timestamptz
	EndTime       pgtype.Timestamptz
	WalletAddress string
	TotalAmount   int64
	Point         int32
	Status        string
	CreateTime    time.Time
	UpdateTime    time.Time
}

// List user task & task
//
//	SELECT
//	    ut.task_seqno,
//	    t.task_name,
//	    t.task_desc,
//	    t.start_time,
//	    t.end_time,
//	    ut.wallet_address,
//	    ut.total_amount,
//	    ut.point,
//	    ut.status,
//	    ut.create_time,
//	    ut.update_time
//	FROM user_task ut
//	LEFT JOIN task t ON ut.task_seqno = t.seqno
//	WHERE ut.wallet_address = $1
//	ORDER BY t.start_time desc
func (q *Queries) ListUserTask_Join(ctx context.Context, walletAddress string) ([]ListUserTask_JoinRow, error) {
	rows, err := q.db.Query(ctx, listUserTask_Join, walletAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserTask_JoinRow
	for rows.Next() {
		var i ListUserTask_JoinRow
		if err := rows.Scan(
			&i.TaskSeqno,
			&i.TaskName,
			&i.TaskDesc,
			&i.StartTime,
			&i.EndTime,
			&i.WalletAddress,
			&i.TotalAmount,
			&i.Point,
			&i.Status,
			&i.CreateTime,
			&i.UpdateTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserTask = `-- name: UpdateUserTask :one
UPDATE user_task
SET total_amount = $2, point = $3, status = $4, update_time = $5
WHERE task_seqno = $1 AND wallet_address = $6
RETURNING task_seqno, wallet_address, total_amount, point, status, create_time, update_time
`

type UpdateUserTaskParams struct {
	TaskSeqno     int32
	TotalAmount   int64
	Point         int32
	Status        string
	UpdateTime    time.Time
	WalletAddress string
}

// Update user task
//
//	UPDATE user_task
//	SET total_amount = $2, point = $3, status = $4, update_time = $5
//	WHERE task_seqno = $1 AND wallet_address = $6
//	RETURNING task_seqno, wallet_address, total_amount, point, status, create_time, update_time
func (q *Queries) UpdateUserTask(ctx context.Context, arg UpdateUserTaskParams) (UserTask, error) {
	row := q.db.QueryRow(ctx, updateUserTask,
		arg.TaskSeqno,
		arg.TotalAmount,
		arg.Point,
		arg.Status,
		arg.UpdateTime,
		arg.WalletAddress,
	)
	var i UserTask
	err := row.Scan(
		&i.TaskSeqno,
		&i.WalletAddress,
		&i.TotalAmount,
		&i.Point,
		&i.Status,
		&i.CreateTime,
		&i.UpdateTime,
	)
	return i, err
}
