// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: block_query.sql

package postgres_sqlc

import (
	"context"
	"time"
)

const createUniswapUSDCETHPairSwapLog = `-- name: CreateUniswapUSDCETHPairSwapLog :one
INSERT INTO uniswap_usdc_eth_pair_swap_log (
    block_sender, block_number, block_time, tx_hash, amount0_in, amount0_out, amount1_in, amount1_out
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING block_sender, block_number, block_time, tx_hash, amount0_in, amount0_out, amount1_in, amount1_out
`

type CreateUniswapUSDCETHPairSwapLogParams struct {
	BlockSender string
	BlockNumber int64
	BlockTime   time.Time
	TxHash      string
	Amount0In   int64
	Amount0Out  int64
	Amount1In   int64
	Amount1Out  int64
}

// Create Uniswap USDC/ETH pair swap log
//
//	INSERT INTO uniswap_usdc_eth_pair_swap_log (
//	    block_sender, block_number, block_time, tx_hash, amount0_in, amount0_out, amount1_in, amount1_out
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6, $7, $8
//	)
//	RETURNING block_sender, block_number, block_time, tx_hash, amount0_in, amount0_out, amount1_in, amount1_out
func (q *Queries) CreateUniswapUSDCETHPairSwapLog(ctx context.Context, arg CreateUniswapUSDCETHPairSwapLogParams) (UniswapUsdcEthPairSwapLog, error) {
	row := q.db.QueryRow(ctx, createUniswapUSDCETHPairSwapLog,
		arg.BlockSender,
		arg.BlockNumber,
		arg.BlockTime,
		arg.TxHash,
		arg.Amount0In,
		arg.Amount0Out,
		arg.Amount1In,
		arg.Amount1Out,
	)
	var i UniswapUsdcEthPairSwapLog
	err := row.Scan(
		&i.BlockSender,
		&i.BlockNumber,
		&i.BlockTime,
		&i.TxHash,
		&i.Amount0In,
		&i.Amount0Out,
		&i.Amount1In,
		&i.Amount1Out,
	)
	return i, err
}

const listUniswapUSDCETHPairSwapLogBySender = `-- name: ListUniswapUSDCETHPairSwapLogBySender :many
SELECT block_sender, block_number, block_time, tx_hash, amount0_in, amount0_out, amount1_in, amount1_out FROM uniswap_usdc_eth_pair_swap_log
WHERE block_sender = $1
ORDER BY block_number
`

// List Uniswap USDC/ETH pair swap log by sender
//
//	SELECT block_sender, block_number, block_time, tx_hash, amount0_in, amount0_out, amount1_in, amount1_out FROM uniswap_usdc_eth_pair_swap_log
//	WHERE block_sender = $1
//	ORDER BY block_number
func (q *Queries) ListUniswapUSDCETHPairSwapLogBySender(ctx context.Context, blockSender string) ([]UniswapUsdcEthPairSwapLog, error) {
	rows, err := q.db.Query(ctx, listUniswapUSDCETHPairSwapLogBySender, blockSender)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UniswapUsdcEthPairSwapLog
	for rows.Next() {
		var i UniswapUsdcEthPairSwapLog
		if err := rows.Scan(
			&i.BlockSender,
			&i.BlockNumber,
			&i.BlockTime,
			&i.TxHash,
			&i.Amount0In,
			&i.Amount0Out,
			&i.Amount1In,
			&i.Amount1Out,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUniswapUSDCETHPairSwapLogByTimestamp = `-- name: ListUniswapUSDCETHPairSwapLogByTimestamp :many
SELECT block_sender, block_number, block_time, tx_hash, amount0_in, amount0_out, amount1_in, amount1_out FROM uniswap_usdc_eth_pair_swap_log
WHERE block_time >= $1 AND block_time <= $2
ORDER BY block_number
`

type ListUniswapUSDCETHPairSwapLogByTimestampParams struct {
	BlockTime   time.Time
	BlockTime_2 time.Time
}

// List Uniswap USDC/ETH pair swap log between timestamp
//
//	SELECT block_sender, block_number, block_time, tx_hash, amount0_in, amount0_out, amount1_in, amount1_out FROM uniswap_usdc_eth_pair_swap_log
//	WHERE block_time >= $1 AND block_time <= $2
//	ORDER BY block_number
func (q *Queries) ListUniswapUSDCETHPairSwapLogByTimestamp(ctx context.Context, arg ListUniswapUSDCETHPairSwapLogByTimestampParams) ([]UniswapUsdcEthPairSwapLog, error) {
	rows, err := q.db.Query(ctx, listUniswapUSDCETHPairSwapLogByTimestamp, arg.BlockTime, arg.BlockTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UniswapUsdcEthPairSwapLog
	for rows.Next() {
		var i UniswapUsdcEthPairSwapLog
		if err := rows.Scan(
			&i.BlockSender,
			&i.BlockNumber,
			&i.BlockTime,
			&i.TxHash,
			&i.Amount0In,
			&i.Amount0Out,
			&i.Amount1In,
			&i.Amount1Out,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
